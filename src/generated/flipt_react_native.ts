// This file was autogenerated by some hot garbage in the `uniffi-bindgen-react-native` crate.
// Trust me, you don't want to mess with it!
import nativeModule, {
  type UniffiRustFutureContinuationCallback,
  type UniffiForeignFuture,
  type UniffiForeignFutureStructU8,
  type UniffiForeignFutureCompleteU8,
  type UniffiForeignFutureStructI8,
  type UniffiForeignFutureCompleteI8,
  type UniffiForeignFutureStructU16,
  type UniffiForeignFutureCompleteU16,
  type UniffiForeignFutureStructI16,
  type UniffiForeignFutureCompleteI16,
  type UniffiForeignFutureStructU32,
  type UniffiForeignFutureCompleteU32,
  type UniffiForeignFutureStructI32,
  type UniffiForeignFutureCompleteI32,
  type UniffiForeignFutureStructU64,
  type UniffiForeignFutureCompleteU64,
  type UniffiForeignFutureStructI64,
  type UniffiForeignFutureCompleteI64,
  type UniffiForeignFutureStructF32,
  type UniffiForeignFutureCompleteF32,
  type UniffiForeignFutureStructF64,
  type UniffiForeignFutureCompleteF64,
  type UniffiForeignFutureStructPointer,
  type UniffiForeignFutureCompletePointer,
  type UniffiForeignFutureStructRustBuffer,
  type UniffiForeignFutureCompleteRustBuffer,
  type UniffiForeignFutureStructVoid,
  type UniffiForeignFutureCompleteVoid,
} from './flipt_react_native-ffi';
import {
  type FfiConverter,
  type UniffiByteArray,
  type UniffiObjectFactory,
  type UniffiRustArcPtr,
  type UnsafeMutableRawPointer,
  AbstractFfiConverterByteArray,
  FfiConverterArray,
  FfiConverterBool,
  FfiConverterFloat64,
  FfiConverterInt32,
  FfiConverterMap,
  FfiConverterObject,
  FfiConverterOptional,
  FfiConverterUInt64,
  RustBuffer,
  UniffiAbstractObject,
  UniffiError,
  UniffiInternalError,
  UniffiRustCaller,
  destructorGuardSymbol,
  pointerLiteralSymbol,
  uniffiCreateFfiConverterString,
  uniffiCreateRecord,
  uniffiTypeNameSymbol,
  variantOrdinalSymbol,
} from 'uniffi-bindgen-react-native';

// Get converters from the other files, if any.
const uniffiCaller = new UniffiRustCaller(() => ({ code: 0 }));

const uniffiIsDebug =
  // @ts-ignore -- The process global might not be defined
  typeof process !== 'object' ||
  // @ts-ignore -- The process global might not be defined
  process?.env?.NODE_ENV !== 'production' ||
  false;
// Public interface members begin here.

export type BatchEvaluationResponse = {
  responses: Array<EvaluationResponse>;
  requestDurationMillis: /*f64*/ number;
};

/**
 * Generated factory for {@link BatchEvaluationResponse} record objects.
 */
export const BatchEvaluationResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      BatchEvaluationResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link BatchEvaluationResponse}, with defaults specified
     * in Rust, in the {@link flipt_react_native} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link BatchEvaluationResponse}, with defaults specified
     * in Rust, in the {@link flipt_react_native} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link flipt_react_native} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<BatchEvaluationResponse>,
  });
})();

const FfiConverterTypeBatchEvaluationResponse = (() => {
  type TypeName = BatchEvaluationResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        responses: FfiConverterArrayTypeEvaluationResponse.read(from),
        requestDurationMillis: FfiConverterFloat64.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterArrayTypeEvaluationResponse.write(value.responses, into);
      FfiConverterFloat64.write(value.requestDurationMillis, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterArrayTypeEvaluationResponse.allocationSize(
          value.responses
        ) + FfiConverterFloat64.allocationSize(value.requestDurationMillis)
      );
    }
  }
  return new FFIConverter();
})();

export type BooleanEvaluationResponse = {
  enabled: boolean;
  flagKey: string;
  reason: string;
  requestDurationMillis: /*f64*/ number;
  timestamp: string;
};

/**
 * Generated factory for {@link BooleanEvaluationResponse} record objects.
 */
export const BooleanEvaluationResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      BooleanEvaluationResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link BooleanEvaluationResponse}, with defaults specified
     * in Rust, in the {@link flipt_react_native} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link BooleanEvaluationResponse}, with defaults specified
     * in Rust, in the {@link flipt_react_native} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link flipt_react_native} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<BooleanEvaluationResponse>,
  });
})();

const FfiConverterTypeBooleanEvaluationResponse = (() => {
  type TypeName = BooleanEvaluationResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        enabled: FfiConverterBool.read(from),
        flagKey: FfiConverterString.read(from),
        reason: FfiConverterString.read(from),
        requestDurationMillis: FfiConverterFloat64.read(from),
        timestamp: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterBool.write(value.enabled, into);
      FfiConverterString.write(value.flagKey, into);
      FfiConverterString.write(value.reason, into);
      FfiConverterFloat64.write(value.requestDurationMillis, into);
      FfiConverterString.write(value.timestamp, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterBool.allocationSize(value.enabled) +
        FfiConverterString.allocationSize(value.flagKey) +
        FfiConverterString.allocationSize(value.reason) +
        FfiConverterFloat64.allocationSize(value.requestDurationMillis) +
        FfiConverterString.allocationSize(value.timestamp)
      );
    }
  }
  return new FFIConverter();
})();

export type ClientOptions = {
  environment: string | undefined;
  namespace: string | undefined;
  url: string | undefined;
  updateInterval: /*u64*/ bigint | undefined;
  reference: string | undefined;
  clientToken: string | undefined;
  fetchMode: string | undefined;
};

/**
 * Generated factory for {@link ClientOptions} record objects.
 */
export const ClientOptions = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<ClientOptions, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ClientOptions}, with defaults specified
     * in Rust, in the {@link flipt_react_native} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ClientOptions}, with defaults specified
     * in Rust, in the {@link flipt_react_native} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link flipt_react_native} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<ClientOptions>,
  });
})();

const FfiConverterTypeClientOptions = (() => {
  type TypeName = ClientOptions;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        environment: FfiConverterOptionalString.read(from),
        namespace: FfiConverterOptionalString.read(from),
        url: FfiConverterOptionalString.read(from),
        updateInterval: FfiConverterOptionalUInt64.read(from),
        reference: FfiConverterOptionalString.read(from),
        clientToken: FfiConverterOptionalString.read(from),
        fetchMode: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterOptionalString.write(value.environment, into);
      FfiConverterOptionalString.write(value.namespace, into);
      FfiConverterOptionalString.write(value.url, into);
      FfiConverterOptionalUInt64.write(value.updateInterval, into);
      FfiConverterOptionalString.write(value.reference, into);
      FfiConverterOptionalString.write(value.clientToken, into);
      FfiConverterOptionalString.write(value.fetchMode, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterOptionalString.allocationSize(value.environment) +
        FfiConverterOptionalString.allocationSize(value.namespace) +
        FfiConverterOptionalString.allocationSize(value.url) +
        FfiConverterOptionalUInt64.allocationSize(value.updateInterval) +
        FfiConverterOptionalString.allocationSize(value.reference) +
        FfiConverterOptionalString.allocationSize(value.clientToken) +
        FfiConverterOptionalString.allocationSize(value.fetchMode)
      );
    }
  }
  return new FFIConverter();
})();

export type ErrorEvaluationResponse = {
  flagKey: string;
  namespaceKey: string;
  reason: string;
};

/**
 * Generated factory for {@link ErrorEvaluationResponse} record objects.
 */
export const ErrorEvaluationResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      ErrorEvaluationResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link ErrorEvaluationResponse}, with defaults specified
     * in Rust, in the {@link flipt_react_native} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link ErrorEvaluationResponse}, with defaults specified
     * in Rust, in the {@link flipt_react_native} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link flipt_react_native} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<ErrorEvaluationResponse>,
  });
})();

const FfiConverterTypeErrorEvaluationResponse = (() => {
  type TypeName = ErrorEvaluationResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        flagKey: FfiConverterString.read(from),
        namespaceKey: FfiConverterString.read(from),
        reason: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.flagKey, into);
      FfiConverterString.write(value.namespaceKey, into);
      FfiConverterString.write(value.reason, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.flagKey) +
        FfiConverterString.allocationSize(value.namespaceKey) +
        FfiConverterString.allocationSize(value.reason)
      );
    }
  }
  return new FFIConverter();
})();

export type EvaluationRequest = {
  flagKey: string;
  entityId: string;
  context: Map<string, string>;
};

/**
 * Generated factory for {@link EvaluationRequest} record objects.
 */
export const EvaluationRequest = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<EvaluationRequest, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link EvaluationRequest}, with defaults specified
     * in Rust, in the {@link flipt_react_native} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link EvaluationRequest}, with defaults specified
     * in Rust, in the {@link flipt_react_native} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link flipt_react_native} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<EvaluationRequest>,
  });
})();

const FfiConverterTypeEvaluationRequest = (() => {
  type TypeName = EvaluationRequest;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        flagKey: FfiConverterString.read(from),
        entityId: FfiConverterString.read(from),
        context: FfiConverterMapStringString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.flagKey, into);
      FfiConverterString.write(value.entityId, into);
      FfiConverterMapStringString.write(value.context, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.flagKey) +
        FfiConverterString.allocationSize(value.entityId) +
        FfiConverterMapStringString.allocationSize(value.context)
      );
    }
  }
  return new FFIConverter();
})();

export type EvaluationResponse = {
  responseType: string;
  booleanEvaluationResponse: BooleanEvaluationResponse | undefined;
  variantEvaluationResponse: VariantEvaluationResponse | undefined;
  errorEvaluationResponse: ErrorEvaluationResponse | undefined;
};

/**
 * Generated factory for {@link EvaluationResponse} record objects.
 */
export const EvaluationResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<EvaluationResponse, ReturnType<typeof defaults>>(
      defaults
    );
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link EvaluationResponse}, with defaults specified
     * in Rust, in the {@link flipt_react_native} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link EvaluationResponse}, with defaults specified
     * in Rust, in the {@link flipt_react_native} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link flipt_react_native} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<EvaluationResponse>,
  });
})();

const FfiConverterTypeEvaluationResponse = (() => {
  type TypeName = EvaluationResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        responseType: FfiConverterString.read(from),
        booleanEvaluationResponse:
          FfiConverterOptionalTypeBooleanEvaluationResponse.read(from),
        variantEvaluationResponse:
          FfiConverterOptionalTypeVariantEvaluationResponse.read(from),
        errorEvaluationResponse:
          FfiConverterOptionalTypeErrorEvaluationResponse.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.responseType, into);
      FfiConverterOptionalTypeBooleanEvaluationResponse.write(
        value.booleanEvaluationResponse,
        into
      );
      FfiConverterOptionalTypeVariantEvaluationResponse.write(
        value.variantEvaluationResponse,
        into
      );
      FfiConverterOptionalTypeErrorEvaluationResponse.write(
        value.errorEvaluationResponse,
        into
      );
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.responseType) +
        FfiConverterOptionalTypeBooleanEvaluationResponse.allocationSize(
          value.booleanEvaluationResponse
        ) +
        FfiConverterOptionalTypeVariantEvaluationResponse.allocationSize(
          value.variantEvaluationResponse
        ) +
        FfiConverterOptionalTypeErrorEvaluationResponse.allocationSize(
          value.errorEvaluationResponse
        )
      );
    }
  }
  return new FFIConverter();
})();

export type Flag = {
  key: string;
  enabled: boolean;
  flagType: string;
  description: string | undefined;
};

/**
 * Generated factory for {@link Flag} record objects.
 */
export const Flag = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<Flag, ReturnType<typeof defaults>>(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link Flag}, with defaults specified
     * in Rust, in the {@link flipt_react_native} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link Flag}, with defaults specified
     * in Rust, in the {@link flipt_react_native} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link flipt_react_native} crate.
     */
    defaults: () => Object.freeze(defaults()) as Partial<Flag>,
  });
})();

const FfiConverterTypeFlag = (() => {
  type TypeName = Flag;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        key: FfiConverterString.read(from),
        enabled: FfiConverterBool.read(from),
        flagType: FfiConverterString.read(from),
        description: FfiConverterOptionalString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterString.write(value.key, into);
      FfiConverterBool.write(value.enabled, into);
      FfiConverterString.write(value.flagType, into);
      FfiConverterOptionalString.write(value.description, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterString.allocationSize(value.key) +
        FfiConverterBool.allocationSize(value.enabled) +
        FfiConverterString.allocationSize(value.flagType) +
        FfiConverterOptionalString.allocationSize(value.description)
      );
    }
  }
  return new FFIConverter();
})();

export type VariantEvaluationResponse = {
  flagMatch: boolean;
  segmentKeys: Array<string>;
  reason: string;
  flagKey: string;
  variantKey: string;
  variantAttachment: string;
  requestDurationMillis: /*f64*/ number;
  timestamp: string;
};

/**
 * Generated factory for {@link VariantEvaluationResponse} record objects.
 */
export const VariantEvaluationResponse = (() => {
  const defaults = () => ({});
  const create = (() => {
    return uniffiCreateRecord<
      VariantEvaluationResponse,
      ReturnType<typeof defaults>
    >(defaults);
  })();
  return Object.freeze({
    /**
     * Create a frozen instance of {@link VariantEvaluationResponse}, with defaults specified
     * in Rust, in the {@link flipt_react_native} crate.
     */
    create,

    /**
     * Create a frozen instance of {@link VariantEvaluationResponse}, with defaults specified
     * in Rust, in the {@link flipt_react_native} crate.
     */
    new: create,

    /**
     * Defaults specified in the {@link flipt_react_native} crate.
     */
    defaults: () =>
      Object.freeze(defaults()) as Partial<VariantEvaluationResponse>,
  });
})();

const FfiConverterTypeVariantEvaluationResponse = (() => {
  type TypeName = VariantEvaluationResponse;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      return {
        flagMatch: FfiConverterBool.read(from),
        segmentKeys: FfiConverterArrayString.read(from),
        reason: FfiConverterString.read(from),
        flagKey: FfiConverterString.read(from),
        variantKey: FfiConverterString.read(from),
        variantAttachment: FfiConverterString.read(from),
        requestDurationMillis: FfiConverterFloat64.read(from),
        timestamp: FfiConverterString.read(from),
      };
    }
    write(value: TypeName, into: RustBuffer): void {
      FfiConverterBool.write(value.flagMatch, into);
      FfiConverterArrayString.write(value.segmentKeys, into);
      FfiConverterString.write(value.reason, into);
      FfiConverterString.write(value.flagKey, into);
      FfiConverterString.write(value.variantKey, into);
      FfiConverterString.write(value.variantAttachment, into);
      FfiConverterFloat64.write(value.requestDurationMillis, into);
      FfiConverterString.write(value.timestamp, into);
    }
    allocationSize(value: TypeName): number {
      return (
        FfiConverterBool.allocationSize(value.flagMatch) +
        FfiConverterArrayString.allocationSize(value.segmentKeys) +
        FfiConverterString.allocationSize(value.reason) +
        FfiConverterString.allocationSize(value.flagKey) +
        FfiConverterString.allocationSize(value.variantKey) +
        FfiConverterString.allocationSize(value.variantAttachment) +
        FfiConverterFloat64.allocationSize(value.requestDurationMillis) +
        FfiConverterString.allocationSize(value.timestamp)
      );
    }
  }
  return new FFIConverter();
})();

const stringConverter = {
  stringToBytes: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_arraybuffer(
        s,
        status
      )
    ),
  bytesToString: (ab: UniffiByteArray) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__arraybuffer_to_string(
        ab,
        status
      )
    ),
  stringByteLength: (s: string) =>
    uniffiCaller.rustCall((status) =>
      nativeModule().ubrn_uniffi_internal_fn_func_ffi__string_to_byte_length(
        s,
        status
      )
    ),
};
const FfiConverterString = uniffiCreateFfiConverterString(stringConverter);

// Error type: FliptError

// Enum: FliptError
export enum FliptError_Tags {
  Internal = 'Internal',
  UnknownFlag = 'UnknownFlag',
  InvalidRequest = 'InvalidRequest',
  ConnectionError = 'ConnectionError',
}
export const FliptError = (() => {
  type Internal__interface = {
    tag: FliptError_Tags.Internal;
    inner: Readonly<{ message: string }>;
  };

  class Internal_ extends UniffiError implements Internal__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FliptError';
    readonly tag = FliptError_Tags.Internal;
    readonly inner: Readonly<{ message: string }>;
    constructor(inner: { message: string }) {
      super('FliptError', 'Internal');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { message: string }): Internal_ {
      return new Internal_(inner);
    }

    static instanceOf(obj: any): obj is Internal_ {
      return obj.tag === FliptError_Tags.Internal;
    }

    static hasInner(obj: any): obj is Internal_ {
      return Internal_.instanceOf(obj);
    }

    static getInner(obj: Internal_): Readonly<{ message: string }> {
      return obj.inner;
    }
  }

  type UnknownFlag__interface = {
    tag: FliptError_Tags.UnknownFlag;
    inner: Readonly<{ message: string }>;
  };

  class UnknownFlag_ extends UniffiError implements UnknownFlag__interface {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FliptError';
    readonly tag = FliptError_Tags.UnknownFlag;
    readonly inner: Readonly<{ message: string }>;
    constructor(inner: { message: string }) {
      super('FliptError', 'UnknownFlag');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { message: string }): UnknownFlag_ {
      return new UnknownFlag_(inner);
    }

    static instanceOf(obj: any): obj is UnknownFlag_ {
      return obj.tag === FliptError_Tags.UnknownFlag;
    }

    static hasInner(obj: any): obj is UnknownFlag_ {
      return UnknownFlag_.instanceOf(obj);
    }

    static getInner(obj: UnknownFlag_): Readonly<{ message: string }> {
      return obj.inner;
    }
  }

  type InvalidRequest__interface = {
    tag: FliptError_Tags.InvalidRequest;
    inner: Readonly<{ message: string }>;
  };

  class InvalidRequest_
    extends UniffiError
    implements InvalidRequest__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FliptError';
    readonly tag = FliptError_Tags.InvalidRequest;
    readonly inner: Readonly<{ message: string }>;
    constructor(inner: { message: string }) {
      super('FliptError', 'InvalidRequest');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { message: string }): InvalidRequest_ {
      return new InvalidRequest_(inner);
    }

    static instanceOf(obj: any): obj is InvalidRequest_ {
      return obj.tag === FliptError_Tags.InvalidRequest;
    }

    static hasInner(obj: any): obj is InvalidRequest_ {
      return InvalidRequest_.instanceOf(obj);
    }

    static getInner(obj: InvalidRequest_): Readonly<{ message: string }> {
      return obj.inner;
    }
  }

  type ConnectionError__interface = {
    tag: FliptError_Tags.ConnectionError;
    inner: Readonly<{ message: string }>;
  };

  class ConnectionError_
    extends UniffiError
    implements ConnectionError__interface
  {
    /**
     * @private
     * This field is private and should not be used, use `tag` instead.
     */
    readonly [uniffiTypeNameSymbol] = 'FliptError';
    readonly tag = FliptError_Tags.ConnectionError;
    readonly inner: Readonly<{ message: string }>;
    constructor(inner: { message: string }) {
      super('FliptError', 'ConnectionError');
      this.inner = Object.freeze(inner);
    }

    static new(inner: { message: string }): ConnectionError_ {
      return new ConnectionError_(inner);
    }

    static instanceOf(obj: any): obj is ConnectionError_ {
      return obj.tag === FliptError_Tags.ConnectionError;
    }

    static hasInner(obj: any): obj is ConnectionError_ {
      return ConnectionError_.instanceOf(obj);
    }

    static getInner(obj: ConnectionError_): Readonly<{ message: string }> {
      return obj.inner;
    }
  }

  function instanceOf(obj: any): obj is FliptError {
    return obj[uniffiTypeNameSymbol] === 'FliptError';
  }

  return Object.freeze({
    instanceOf,
    Internal: Internal_,
    UnknownFlag: UnknownFlag_,
    InvalidRequest: InvalidRequest_,
    ConnectionError: ConnectionError_,
  });
})();

export type FliptError = InstanceType<
  (typeof FliptError)[keyof Omit<typeof FliptError, 'instanceOf'>]
>;

// FfiConverter for enum FliptError
const FfiConverterTypeFliptError = (() => {
  const ordinalConverter = FfiConverterInt32;
  type TypeName = FliptError;
  class FFIConverter extends AbstractFfiConverterByteArray<TypeName> {
    read(from: RustBuffer): TypeName {
      switch (ordinalConverter.read(from)) {
        case 1:
          return new FliptError.Internal({
            message: FfiConverterString.read(from),
          });
        case 2:
          return new FliptError.UnknownFlag({
            message: FfiConverterString.read(from),
          });
        case 3:
          return new FliptError.InvalidRequest({
            message: FfiConverterString.read(from),
          });
        case 4:
          return new FliptError.ConnectionError({
            message: FfiConverterString.read(from),
          });
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    write(value: TypeName, into: RustBuffer): void {
      switch (value.tag) {
        case FliptError_Tags.Internal: {
          ordinalConverter.write(1, into);
          const inner = value.inner;
          FfiConverterString.write(inner.message, into);
          return;
        }
        case FliptError_Tags.UnknownFlag: {
          ordinalConverter.write(2, into);
          const inner = value.inner;
          FfiConverterString.write(inner.message, into);
          return;
        }
        case FliptError_Tags.InvalidRequest: {
          ordinalConverter.write(3, into);
          const inner = value.inner;
          FfiConverterString.write(inner.message, into);
          return;
        }
        case FliptError_Tags.ConnectionError: {
          ordinalConverter.write(4, into);
          const inner = value.inner;
          FfiConverterString.write(inner.message, into);
          return;
        }
        default:
          // Throwing from here means that FliptError_Tags hasn't matched an ordinal.
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
    allocationSize(value: TypeName): number {
      switch (value.tag) {
        case FliptError_Tags.Internal: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(1);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        case FliptError_Tags.UnknownFlag: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(2);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        case FliptError_Tags.InvalidRequest: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(3);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        case FliptError_Tags.ConnectionError: {
          const inner = value.inner;
          let size = ordinalConverter.allocationSize(4);
          size += FfiConverterString.allocationSize(inner.message);
          return size;
        }
        default:
          throw new UniffiInternalError.UnexpectedEnumCase();
      }
    }
  }
  return new FFIConverter();
})();

// FfiConverter for Map<string, string>
const FfiConverterMapStringString = new FfiConverterMap(
  FfiConverterString,
  FfiConverterString
);

export interface FliptClientInterface {
  close(): void;
  evaluateBatch(
    requests: Array<EvaluationRequest>
  ) /*throws*/ : BatchEvaluationResponse;
  evaluateBoolean(
    request: EvaluationRequest
  ) /*throws*/ : BooleanEvaluationResponse;
  evaluateVariant(
    request: EvaluationRequest
  ) /*throws*/ : VariantEvaluationResponse;
  listFlags() /*throws*/ : Array<Flag>;
  refresh() /*throws*/ : void;
}

export class FliptClient
  extends UniffiAbstractObject
  implements FliptClientInterface
{
  readonly [uniffiTypeNameSymbol] = 'FliptClient';
  readonly [destructorGuardSymbol]: UniffiRustArcPtr;
  readonly [pointerLiteralSymbol]: UnsafeMutableRawPointer;
  constructor(opts: ClientOptions) /*throws*/ {
    super();
    const pointer = uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeFliptError.lift.bind(
        FfiConverterTypeFliptError
      ),
      /*caller:*/ (callStatus) => {
        return nativeModule().ubrn_uniffi_flipt_react_native_fn_constructor_fliptclient_new(
          FfiConverterTypeClientOptions.lower(opts),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
    this[pointerLiteralSymbol] = pointer;
    this[destructorGuardSymbol] =
      uniffiTypeFliptClientObjectFactory.bless(pointer);
  }

  public close(): void {
    uniffiCaller.rustCall(
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_flipt_react_native_fn_method_fliptclient_close(
          uniffiTypeFliptClientObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  public evaluateBatch(
    requests: Array<EvaluationRequest>
  ): BatchEvaluationResponse /*throws*/ {
    return FfiConverterTypeBatchEvaluationResponse.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeFliptError.lift.bind(
          FfiConverterTypeFliptError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_flipt_react_native_fn_method_fliptclient_evaluate_batch(
            uniffiTypeFliptClientObjectFactory.clonePointer(this),
            FfiConverterArrayTypeEvaluationRequest.lower(requests),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public evaluateBoolean(
    request: EvaluationRequest
  ): BooleanEvaluationResponse /*throws*/ {
    return FfiConverterTypeBooleanEvaluationResponse.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeFliptError.lift.bind(
          FfiConverterTypeFliptError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_flipt_react_native_fn_method_fliptclient_evaluate_boolean(
            uniffiTypeFliptClientObjectFactory.clonePointer(this),
            FfiConverterTypeEvaluationRequest.lower(request),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public evaluateVariant(
    request: EvaluationRequest
  ): VariantEvaluationResponse /*throws*/ {
    return FfiConverterTypeVariantEvaluationResponse.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeFliptError.lift.bind(
          FfiConverterTypeFliptError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_flipt_react_native_fn_method_fliptclient_evaluate_variant(
            uniffiTypeFliptClientObjectFactory.clonePointer(this),
            FfiConverterTypeEvaluationRequest.lower(request),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public listFlags(): Array<Flag> /*throws*/ {
    return FfiConverterArrayTypeFlag.lift(
      uniffiCaller.rustCallWithError(
        /*liftError:*/ FfiConverterTypeFliptError.lift.bind(
          FfiConverterTypeFliptError
        ),
        /*caller:*/ (callStatus) => {
          return nativeModule().ubrn_uniffi_flipt_react_native_fn_method_fliptclient_list_flags(
            uniffiTypeFliptClientObjectFactory.clonePointer(this),
            callStatus
          );
        },
        /*liftString:*/ FfiConverterString.lift
      )
    );
  }

  public refresh(): void /*throws*/ {
    uniffiCaller.rustCallWithError(
      /*liftError:*/ FfiConverterTypeFliptError.lift.bind(
        FfiConverterTypeFliptError
      ),
      /*caller:*/ (callStatus) => {
        nativeModule().ubrn_uniffi_flipt_react_native_fn_method_fliptclient_refresh(
          uniffiTypeFliptClientObjectFactory.clonePointer(this),
          callStatus
        );
      },
      /*liftString:*/ FfiConverterString.lift
    );
  }

  /**
   * {@inheritDoc uniffi-bindgen-react-native#UniffiAbstractObject.uniffiDestroy}
   */
  uniffiDestroy(): void {
    const ptr = (this as any)[destructorGuardSymbol];
    if (ptr !== undefined) {
      const pointer = uniffiTypeFliptClientObjectFactory.pointer(this);
      uniffiTypeFliptClientObjectFactory.freePointer(pointer);
      uniffiTypeFliptClientObjectFactory.unbless(ptr);
      delete (this as any)[destructorGuardSymbol];
    }
  }

  static instanceOf(obj: any): obj is FliptClient {
    return uniffiTypeFliptClientObjectFactory.isConcreteType(obj);
  }
}

const uniffiTypeFliptClientObjectFactory: UniffiObjectFactory<FliptClientInterface> =
  (() => {
    return {
      create(pointer: UnsafeMutableRawPointer): FliptClientInterface {
        const instance = Object.create(FliptClient.prototype);
        instance[pointerLiteralSymbol] = pointer;
        instance[destructorGuardSymbol] = this.bless(pointer);
        instance[uniffiTypeNameSymbol] = 'FliptClient';
        return instance;
      },

      bless(p: UnsafeMutableRawPointer): UniffiRustArcPtr {
        return uniffiCaller.rustCall(
          /*caller:*/ (status) =>
            nativeModule().ubrn_uniffi_internal_fn_method_fliptclient_ffi__bless_pointer(
              p,
              status
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      unbless(ptr: UniffiRustArcPtr) {
        ptr.markDestroyed();
      },

      pointer(obj: FliptClientInterface): UnsafeMutableRawPointer {
        if ((obj as any)[destructorGuardSymbol] === undefined) {
          throw new UniffiInternalError.UnexpectedNullPointer();
        }
        return (obj as any)[pointerLiteralSymbol];
      },

      clonePointer(obj: FliptClientInterface): UnsafeMutableRawPointer {
        const pointer = this.pointer(obj);
        return uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_flipt_react_native_fn_clone_fliptclient(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      freePointer(pointer: UnsafeMutableRawPointer): void {
        uniffiCaller.rustCall(
          /*caller:*/ (callStatus) =>
            nativeModule().ubrn_uniffi_flipt_react_native_fn_free_fliptclient(
              pointer,
              callStatus
            ),
          /*liftString:*/ FfiConverterString.lift
        );
      },

      isConcreteType(obj: any): obj is FliptClientInterface {
        return (
          obj[destructorGuardSymbol] &&
          obj[uniffiTypeNameSymbol] === 'FliptClient'
        );
      },
    };
  })();
// FfiConverter for FliptClientInterface
const FfiConverterTypeFliptClient = new FfiConverterObject(
  uniffiTypeFliptClientObjectFactory
);

// FfiConverter for BooleanEvaluationResponse | undefined
const FfiConverterOptionalTypeBooleanEvaluationResponse =
  new FfiConverterOptional(FfiConverterTypeBooleanEvaluationResponse);

// FfiConverter for ErrorEvaluationResponse | undefined
const FfiConverterOptionalTypeErrorEvaluationResponse =
  new FfiConverterOptional(FfiConverterTypeErrorEvaluationResponse);

// FfiConverter for VariantEvaluationResponse | undefined
const FfiConverterOptionalTypeVariantEvaluationResponse =
  new FfiConverterOptional(FfiConverterTypeVariantEvaluationResponse);

// FfiConverter for string | undefined
const FfiConverterOptionalString = new FfiConverterOptional(FfiConverterString);

// FfiConverter for /*u64*/bigint | undefined
const FfiConverterOptionalUInt64 = new FfiConverterOptional(FfiConverterUInt64);

// FfiConverter for Array<EvaluationRequest>
const FfiConverterArrayTypeEvaluationRequest = new FfiConverterArray(
  FfiConverterTypeEvaluationRequest
);

// FfiConverter for Array<EvaluationResponse>
const FfiConverterArrayTypeEvaluationResponse = new FfiConverterArray(
  FfiConverterTypeEvaluationResponse
);

// FfiConverter for Array<Flag>
const FfiConverterArrayTypeFlag = new FfiConverterArray(FfiConverterTypeFlag);

// FfiConverter for Array<string>
const FfiConverterArrayString = new FfiConverterArray(FfiConverterString);

/**
 * This should be called before anything else.
 *
 * It is likely that this is being done for you by the library's `index.ts`.
 *
 * It checks versions of uniffi between when the Rust scaffolding was generated
 * and when the bindings were generated.
 *
 * It also initializes the machinery to enable Rust to talk back to Javascript.
 */
function uniffiEnsureInitialized() {
  // Get the bindings contract version from our ComponentInterface
  const bindingsContractVersion = 29;
  // Get the scaffolding contract version by calling the into the dylib
  const scaffoldingContractVersion =
    nativeModule().ubrn_ffi_flipt_react_native_uniffi_contract_version();
  if (bindingsContractVersion !== scaffoldingContractVersion) {
    throw new UniffiInternalError.ContractVersionMismatch(
      scaffoldingContractVersion,
      bindingsContractVersion
    );
  }
  if (
    nativeModule().ubrn_uniffi_flipt_react_native_checksum_method_fliptclient_close() !==
    38964
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_flipt_react_native_checksum_method_fliptclient_close'
    );
  }
  if (
    nativeModule().ubrn_uniffi_flipt_react_native_checksum_method_fliptclient_evaluate_batch() !==
    37777
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_flipt_react_native_checksum_method_fliptclient_evaluate_batch'
    );
  }
  if (
    nativeModule().ubrn_uniffi_flipt_react_native_checksum_method_fliptclient_evaluate_boolean() !==
    43241
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_flipt_react_native_checksum_method_fliptclient_evaluate_boolean'
    );
  }
  if (
    nativeModule().ubrn_uniffi_flipt_react_native_checksum_method_fliptclient_evaluate_variant() !==
    41883
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_flipt_react_native_checksum_method_fliptclient_evaluate_variant'
    );
  }
  if (
    nativeModule().ubrn_uniffi_flipt_react_native_checksum_method_fliptclient_list_flags() !==
    56603
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_flipt_react_native_checksum_method_fliptclient_list_flags'
    );
  }
  if (
    nativeModule().ubrn_uniffi_flipt_react_native_checksum_method_fliptclient_refresh() !==
    35340
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_flipt_react_native_checksum_method_fliptclient_refresh'
    );
  }
  if (
    nativeModule().ubrn_uniffi_flipt_react_native_checksum_constructor_fliptclient_new() !==
    34374
  ) {
    throw new UniffiInternalError.ApiChecksumMismatch(
      'uniffi_flipt_react_native_checksum_constructor_fliptclient_new'
    );
  }
}

export default Object.freeze({
  initialize: uniffiEnsureInitialized,
  converters: {
    FfiConverterTypeBatchEvaluationResponse,
    FfiConverterTypeBooleanEvaluationResponse,
    FfiConverterTypeClientOptions,
    FfiConverterTypeErrorEvaluationResponse,
    FfiConverterTypeEvaluationRequest,
    FfiConverterTypeEvaluationResponse,
    FfiConverterTypeFlag,
    FfiConverterTypeFliptClient,
    FfiConverterTypeFliptError,
    FfiConverterTypeVariantEvaluationResponse,
  },
});
